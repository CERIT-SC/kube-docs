# Tutorial pro Hello World

Zde poskytujeme krátký tutoriál o tom, jak nasadit vlastní webový server v Kubernetes pomocí `kubectl`. Použijeme již existující příklad z [hello-kubernetes](https://github.com/paulbouwer/hello-kubernetes), ale s trochu více vysvětlením. Tento tutoriál rozhodně neobsahuje vše, co lze nakonfigurovat a udělat, ale spíše poskytuje první zkušenosti s Kubernetes.

Chystáme se nasadit jednoduchý web, který běží z Docker image a zobrazuje "Hello world" spolu s názvem `Pod` a informacemi o `node OS`.

*DŮLEŽITÉ*
Pokud není dohodnuto jinak, pro osobní projekty a experimenty můžete použít `kuba-cluster`. Zde musíte pracovat ve svém namespace a jeho název je odvozen od vašeho příjmení s přidaným `-ns`. Nicméně, názvy nejsou jedinečné, a proto doporučujeme zkontrolovat svůj na `Rancher` v rozbalovacím menu v levém horním rohu `kuba-cluster` a `Project/Namespaces`.

![kube ns](/img/ceritsc/hello-ns.jpg)

## Vytvoření souborů

Musíme vytvořit alespoň 3 Kubernetes zdroje pro nasazení aplikace -- `Deployment`, `Service`, `Ingress`.

### 1. Deployment
Vytvořte nový adresář, např. `hello-world`, a uvnitř vytvořte nový soubor `deployment.yaml` s obsahem:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-kubernetes
spec:
  replicas: 3
  selector:
    matchLabels:
      app: hello-kubernetes
  template:
    metadata:
      labels:
        app: hello-kubernetes
    spec:
      securityContext:
        runAsUser: 1000
        runAsNonRoot: true
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: hello-kubernetes
        image: paulbouwer/hello-kubernetes:1.9
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
        ports:
        - containerPort: 8080
```
Tento příkladový soubor se skládá z polí:
- `.metadata`
  - `.name` označuje název nasazení
- `.spec`
  - `.replicas` označuje počet replikovaných Podů, které budou vytvořeny
  - `.selector` pole definuje, jak `Deployment` najde, které `Pods` spravovat. Zde je vybrána značka definovaná v šabloně `Pod` (`app: hello-kubernetes`), sofistikovaná pravidla výběru jsou možná, pokud šablona `Pod` sama splňuje pravidlo
  - `.template`
    - `.metadata.labels` `Pods` jsou zde označeny
    - `.spec` specifikace šablony `Pod`
      -  `.containers` pole definující kontejnery, které budou běžet. Každá položka musí mít `name, image`
      -  `.containers.securityContext` definuje, pod jakým uživatelským a volitelně skupinovým uživatelským účtem bude kontejner běžet. *DŮLEŽITÉ* kontejnery musí běžet pod uživatelským účtem a skupinou, které nejsou root, kvůli bezpečnosti. Více v části o *PodSecurityPolicy* později

Kompletní referenční dokumentace pro zdroje a jejich povolená pole a podpole je k dispozici [online](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/). Nezapomeňte na správné odsazení!

### 2. Service
Za druhé, musíme vytvořit `Service`, což je abstraktní způsob, jak vystavit aplikaci jako síťovou službu.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: hello-kubernetes-svc
spec:
  type: ClusterIP
  ports:
  - name: hello-kubernetes-port
    port: 80
    targetPort: 8080
  selector:
    app: hello-kubernetes
```
Tento soubor vytváří nový objekt `Service` s názvem "hello-kubernetes-svc", který cílí na TCP port 8080 na jakémkoli `Pod` označeném `app=hello-kubernetes`.

Služba může mapovat jakýkoli příchozí port na targetPort. Ve výchozím nastavení je targetPort nastaven na stejnou hodnotu jako pole port. Výchozí protokol je TCP, ale mohou být použity i další podporované protokoly (UDP, HTTP, SCTP, PROXY).

### 3. Ingress

Nakonec musíme vytvořit `Ingress`, který vystavuje HTTP a HTTPS cesty ze světa ven do světa clusteru. Provoz je řízen pravidly nastavenými v tomto zdroji.
Je možné vystavit vaše nasazení [2 způsoby](../kubernetes/expose.html), ale zde použijeme cluster LoadBalancer s vytvořením pouze nového DNS názvu.
Můžete použít jakýkoli název, který chcete, ale musí splňovat 2 požadavky:
- název se skládá pouze z písmen, čísel a '-'
- název končí na `.dyn.cloud.e-infra.cz`

Název je vyplněn v `spec.rules.host` a v `spec.tls`. Než použijete jakýkoli název, zkontrolujte v prohlížeči, zda již neexistuje. Po vytvoření trvá minutu, než se vytvoří nový DNS záznam, takže vaše aplikace nebude okamžitě dostupná na zadaném názvu, počkejte jednu minutu.

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: hello-kubernetes-ingress
  annotations:
    kubernetes.io/tls-acme: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - "test-hello.dyn.cloud.e-infra.cz"
      secretName: test-hello-dyn-cloud-e-infra-cz-tls
  rules:
  - host: "test-hello.dyn.cloud.e-infra.cz"
    http:
      paths:
      - backend:
          service:
            name: hello-kubernetes-svc
            port:
              number: 80
        pathType: ImplementationSpecific
```

Tento příkladový soubor se skládá z polí:
- `.metadata`
  - `.name` označuje název
  - `.annotations` ingress často používá anotace k nastavení možností v závislosti na ingress controlleru. Používáme `nginx` controller a možné anotace jsou uvedeny [zde](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/). Ty, které jsou zde použity, jsou nezbytné pro správnou funkčnost a automaticky vytvářejí TLS certifikát, takže se nemusíte obávat o HTTPS - je to poskytováno automaticky
 - `.spec` zahrnuje všechny informace potřebné k nastavení LB, ale především zahrnuje pravidla, která se shodují se všemi příchozími požadavky
  - `.tls` zajišťuje zabezpečení `Ingress`
    - `hosts` musí přesně odpovídat DNS názvu, který bude použit
    - `secretName` musí odpovídat DNS názvu, ale *všechny tečky jsou nahrazeny '-' a -tls je přidáno na konec*
  - `.rules` je nejdůležitější část
    - `host` je volitelný, pokud je poskytnut, pravidla se vztahují na tento host
    - `paths` (například, `/testpath`), z nichž každá má přidružený backend definovaný s `service.name` a `service.port.name` nebo `service.port.number`. `service.port.number` je port, který je vystaven službou, proto je v službě označen jako `spec.ports.port`, podobně `service.ports.[i].name` je ekvivalentní `spec.ports.[i].name`. Typ cesty může být specifikován, více o tom [zde](https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types)

### 4. Vytvořit
Nyní vytvořte všechny zdroje s použitím celého adresáře jako argumentu a specifikujte svůj namespace
```bash
kubectl apply -f hello-world -n [namespace]
deployment.apps/hello-kubernetes created
ingress.networking.k8s.io/hello-kubernetes-ingress created
service/hello-kubernetes-svc created
```

Můžete zkontrolovat stav nasazených zdrojů pomocí `kubectl get [pods | services | ingress] -n [namespace]` a když budou všechny v provozu, můžete přistoupit na URL a zobrazí se vám ukázková stránka.
![hello](/img/ceritsc/hello.png)

POZNÁMKA: pokud máte problémy s chybovou zprávou 'Config not found', podívejte se [sem](../kubernetes/kubectl) pro další informace

## Další přizpůsobení
Můžete specifikovat různé pole v každém souboru zdroje, z nichž mnohé zde nejsou použity. Jednou z více žádaných funkcí je předávání proměnných prostředí do `Deployments`, pokud potřebné kontejnery nějaké mají. V našem nasazení použijeme jednu proměnnou prostředí ke změně zobrazené zprávy. Na konci přidejte novou sekci `env`, která předá hodnotu do podu. Poté znovu spusťte `kubectl apply -f hello-world -n [namespace]`, abyste aplikovali změny. Když nyní přistoupíte na webovou stránku, zobrazí se nová zpráva!

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-kubernetes
spec:
  replicas: 1
  selector:
    matchLabels:
      app: hello-kubernetes
  template:
    metadata:
      labels:
        app: hello-kubernetes
    spec:
      securityContext:
        runAsUser: 1000
        runAsNonRoot: true
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: hello-kubernetes
        image: paulbouwer/hello-kubernetes:1.9
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
        ports:
        - containerPort: 8080
        env:
        - name: MESSAGE
          value: Hello from the other side!
```

![hello2](/img/ceritsc/hello2.png)

Další přizpůsobení mohou zahrnovat:
- vytvoření `Secret` (např. pro heslo) a jeho připojení do podu do souboru
- vytvoření `ConfigMap` (např. pro větší konfigurace) a jeho připojení do podu
- vytvoření `PersistentVolumeClaim` (úložiště) z NFS (S3 #TODO) a jeho připojení do podu
- vytváření zdrojů jiných typů, např. ReplicaSet, StatefulSet, DaemonSet

## Vytváření PersistentVolumeClaim
Pokud potřebujete použít nějaké trvalé úložiště, můžete vytvořit NFS svazek a připojit ho v `Deployment`.

Příklad: vytvořte soubor `pvc.yaml` a nastavte `[pvc-name]` na požadovaný název a `[capacity]` na požadovanou kapacitu.
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: [pvc-name]
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: [capacity]Gi
  storageClassName: nfs-csi
```
Poté proveďte `kubectl apply -f pvc.yaml -n [namespace]`, kde `[namespace]` je namespace, ve kterém chcete mít pvc vytvořeno. Můžete zkontrolovat, zda vše proběhlo v pořádku, spuštěním
```bash
kubectl get pvc -n [namespace]
NAME                                                               STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
[pvc-name]                                                    Bound    pvc-bcdcea2e-3019-409b-8b0f-18eb50d72c21   1Gi        RWX            csi-nfs        11d
```

Nárok je připojen do `Deployment` (nebo jiných objektů jako `Job, StatefulSet, DaemonSet` atd.) ve 2 krocích:
- vytvořte pole `volumes` pod `spec.template`
- vytvořte pole `volumeMounts` pod `spec.template.spec.containers[container_which_will_have_pvc_mounted]`

`volumes` představuje seznam svazků k připojení s alespoň:
- polem `name`
- typem zdroje, který bude připojen (zde `persistentVolumeClaim`) spolu se jménem zdroje (to, které je specifikováno v `metadata.name` PVC)

`volumeMounts` připojuje položky ze `volumes` na určitou cestu uvnitř kontejneru. V kontejneru vše uložené na cestě `/work` přetrvá a může být sdíleno mezi více kontejnery (jeden svazek může být připojen mnohokrát, pokud je jeho typ `ReadWriteMany`, což NFS je)

```yaml
spec:
  replicas: ...
  selector:
    matchLabels:
      ...
  template:
    metadata:
      labels:
        ...
    spec:
      securityContext:
        runAsNonRoot: true
        seccompProfile:
          type: RuntimeDefault
      containers:
        - name: flask-web
          image: alpine:3.8
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
              - ALL
          ports:
            - containerPort: 8888
          volumeMounts:            <---------------- VOLUME MOUNTS LIST
            - mountPath: /work
              name: shared-volume
      volumes:        <---------------- VOLUMES LIST
      - name: shared-volume
        persistentVolumeClaim:
          claimName: my-first-claim
```

## Politika zabezpečení podů
Z bezpečnostních důvodů není v `kuba-cluster` povoleno vše.

Seznam (ne)povolených akcí:
- Povolit eskalaci oprávnění:  false
- Fs Group: musí běžet jako 1-65535
- Uživatel: musí běžet jako non root
- Doplňkové skupiny: musí běžet jako 1-65535
- Svazky: mohou připojit `configMap, emptyDir, projected, secret, downwardAPI, persistentVolumeClaim`

Jakékoli nasazení, které se pokusí běžet jako root, nebude vytvořeno a zůstane ve stavu podobném (všimněte si READY 0/3 a AVAILABLE 0, logy a popis by řekly více)
```bash
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
hello-kubernetes   0/1     1            0           7m8s
```

## Příkaz Kubectl
Existuje mnoho užitečných příkazů `kubectl`, které lze použít k ověření stavu nasazených zdrojů nebo k získání informací o nich. Některé z nejpohodlnějších:
- `kubectl get [resource]` poskytuje základní informace o zdroji, např. pokud dotazujeme službu, můžeme vidět IP adresu
```bash
 kubectl get service hello-kubernetes-svc -n [namespace]
NAME                   TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)        AGE
hello-kubernetes-svc   LoadBalancer   10.43.124.251   147.251.253.243   80:31334/TCP   3h23m
```
- `kubectl describe [resource]` nabízí podrobné informace o zdroji (výstup je silně zkrácen)
```bash
kubectl describe pod hello-kubernetes -n test-ns
Name:         hello-kubernetes-5547c96ddc-4hxnf
Namespace:    test-ns
Priority:     0
Node:         kub-a10.priv.cerit-sc.cz/10.16.62.19
Start Time:   Tue, 23 Mar 2021 15:22:57 +0100
Labels:       app=hello-kubernetes
              pod-template-hash=5547c96ddc
Annotations:  cni.projectcalico.org/podIP: 10.42.2.25/32
              cni.projectcalico.org/podIPs: 10.42.2.25/32
              kubernetes.io/psp: global-restricted-psp
Status:       Running
IP:           10.42.2.25
IPs:
  IP:           10.42.2.25
Controlled By:  ReplicaSet/hello-kubernetes-5547c96ddc
...
```
- `kubectl get pods -n [namespace]` + `kubectl logs [pod_name] -n [namespace]` zobrazuje logy podu, pokud byly nakonfigurovány nebo pokud došlo k nějakému výstupu. Tato kombinace je velmi užitečná pro ladění.

```bash
kubectl get pods -n test-ns --context kuba-cluster
NAME                                READY   STATUS    RESTARTS   AGE
hello-kubernetes-5547c96ddc-4hxnf   1/1     Running   0          3h19m
 astralmiau@vega  ~/work/test-psp  kubectl logs hello-kubernetes-5547c96ddc-4hxnf -n test-ns

> hello-kubernetes@1.9.0 start /usr/src/app
> node server.js

Listening on: http://hello-kubernetes-5547c96ddc-4hxnf:8080
::ffff:10.42.3.0 - - [23/Mar/2021:14:24:06 +0000] "GET / HTTP/1.1" 200 650 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15"
```

Další kombinace lze nalézt v [rozsáhlém cheat sheetu kubectl](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)
